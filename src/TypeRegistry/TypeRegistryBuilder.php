<?php declare(strict_types=1);
/**
 * @author Lukáš Jelič
 */

namespace Graphette\Graphette\TypeRegistry;


use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpFile;
use Graphette\Graphette\TypeRegistry\Definition\ClassTypeDefinition;
use Graphette\Graphette\TypeRegistry\Definition\PropertyFieldDefinition;
use Graphette\Graphette\TypeRegistry\Definition\TypeDefinition;

class TypeRegistryBuilder {

    private const AUTOGENERATED = '%AUTOGENERATED%';

    private TypeDefinitionProvider $typeDefinitionProvider;

    private PhpFile $file;

    private ClassType $class;

    /**
     * @var array<string, string>
     */
    private array $typeMap = [];

    /**
     * List of invisible types for preventing
     * this case https://webonyx.github.io/graphql-php/type-definitions/interfaces/#prevent-invisible-types
     *
     * @var array<string, string>
     */
    private array $invisibleTypes = [];

    /**
     * @var array<string, string>
     */
    private array $autoInstantiate = [];

    /**
     * @var array<string, array{
     *     className: string,
     *     method: string,
     *     resolveInfoArgName: string|null,
     *     objectValueArgName: string
     * }>
     */
    private array $fieldInfo = [];

    public function __construct(TypeDefinitionProvider $typeDefinitionProvider) {
        $this->typeDefinitionProvider = $typeDefinitionProvider;
    }

    public function build(): string {
        $this->initFile();
        $this->initClass();

        $this->implementInterfaceMethods();

        $this->processWrappingTypes();
        $this->processScalarTypes();
        $this->processStructuredTypes();

        $this->addTypeMap();
        $this->addAutoInstantiateProperty();
        $this->addResolveMethodProperty();
        $this->addInvisibleTypesProperty();

        return (string) $this->file;
    }

    private function initFile(): void {
        $this->file = $file = new PhpFile();

        $file->addComment('This file is auto-generated.');
        $file->addComment('Do not edit this file, edit the source file instead.');
    }

    private function initClass(): void {
        $class = $this->class = $this->file->addClass('TypeRegistry');

        $class->addImplement(TypeRegistry::class);

        $class->addProperty('types')
            ->setPrivate()
            ->setType('array');
    }

    private function implementInterfaceMethods(): void {
        $class = $this->class;

        // add public get method
        $class->addMethod('get')
            ->setPublic()
            ->setReturnType(\GraphQL\Type\Definition\Type::class)
            ->setBody('return $this->types[$name] ??= $this->{$name}();')
            ->addParameter('name')
            ->setType('string');

        // add public get method
        $class->addMethod('has')
            ->setPublic()
            ->setReturnType('bool')
            ->setBody('return isset($this->typeToClassname[$name]) ? true : false;')
            ->addParameter('name')
            ->setType('string');

        // add public getClassNameByType method
        $class->addMethod('getClassNameByType')
            ->setPublic()
            ->setReturnType('string')
            ->setReturnNullable()
            ->setBody('return $this->typeToClassname[$type] ?? null;')
            ->addParameter('type')
            ->setType('string');

        // add public getAutoInstantiateClass method
        $class->addMethod('getAutoInstantiateClass')
            ->setPublic()
            ->setReturnType('string')
            ->setReturnNullable()
            ->setBody('return $this->autoInstantiate[$type] ?? null;')
            ->addParameter('type')
            ->setType('string');

        // add public getResolveMethod method
        $getResolveMethod = $class->addMethod('getFieldInfo')
            ->setPublic()
            ->setReturnType(FieldInfo::class)
			->setBody('
				return unserialize($this->fieldInfo[$type . \'::\' . $field]);
			');
        $getResolveMethod->addParameter('type')
            ->setType('string');
        $getResolveMethod->addParameter('field')
            ->setType('string');

        // add public resolveObjectType method
        $class->addMethod('resolveObjectType')
            ->setPublic()
            ->setReturnType('string')
            ->setReturnNullable()
            ->setBody('return $this->classnameToType[$object::class] ?? null;')
                ->addParameter('object')
                ->setType('object');

        // add private parseInputObject method
        $parseInputObjectMethod = $class->addMethod('parseInputObject')
            ->setPrivate()
            ->setReturnType('mixed')
            ->setBody('$object = new $className;

foreach ($args as $key => $value) {
    try {
        $object->$key = $value;
    } catch (\TypeError $e) {
        throw new \Graphette\Graphette\Exception\Application\NotNullException();
    }
}

return $object;');
        $parseInputObjectMethod->addParameter('args')
            ->setType('array');
        $parseInputObjectMethod->addParameter('className')
            ->setType('string');

        // add public getInvisibleTypes method
        $class->addMethod('getInvisibleTypes')
            ->setPublic()
            ->setReturnType('array')
            ->setBody('$result = [];

        foreach ($this->invisibleTypes as $typeName) {
            $result[] = $this->get($typeName);
        }

        return $result;');
    }

    private function processWrappingTypes(): void {
        $wrappingTypes = TypeDefinitionProvider::getWrappingTypeDefinitions();

        foreach ($wrappingTypes as $type) {
            $this->processWrappingType($type);
        }
    }

    /**
     * @param array{name: string, className: string} $wrappingType
     */
    private function processWrappingType(array $wrappingType): void {
        $name = $wrappingType['name'];
        $className = $wrappingType['className'];

        $this->class->addMethod($name)
            ->setPrivate()
            ->setBody('return new ' . $className . '($value);')
            ->addParameter('value');

    }

    private function processScalarTypes(): void {
        $scalarTypes = TypeDefinitionProvider::getScalarTypeDefinitions();

        foreach ($scalarTypes as $key => $type) {
            $this->processScalarType($type, $key);
        }
    }

    /**
     * @param array{name: string, className: string, builtIn: bool, aliases: array{string}} $scalarType
     * @param string $key
     */
    private function processScalarType(array $scalarType, string $key): void {
        $name = $scalarType['name'];
        $className = $scalarType['className'];

		$this->addScalarFactoryMethod($name, $scalarType['builtIn'], $key, $className);

		$aliases = $scalarType['aliases'] ?? [];

		foreach ($aliases as $alias) {
			$this->addScalarFactoryMethod($alias, $scalarType['builtIn'], $key, $className);
		}
	}

	public function addScalarFactoryMethod(string $name, bool $builtIn, string $key, mixed $className): void {
		$method = $this->class->addMethod($name)
			->setPrivate();

		// webonyx/graphql-php bug workaround (crashes when not using instance from its Type class)
		if ($builtIn ?? false) {
			$method->setBody('return ' . \GraphQL\Type\Definition\Type::class . '::' . $key . '();');
		} else {
			$method->setBody('
				$type = new ' . $className . '();
				$type->name = \'' . $name . '\';
				return $type;');
		}
	}

    private function processStructuredTypes(): void {
        $typeDefinitions = $this->typeDefinitionProvider->getStructuredTypeDefinitions();

        foreach ($typeDefinitions as $typeDefinition) {
            $typeName = $typeDefinition->getName();

            $this->class->addMethod($typeName)
                ->setPrivate()
                ->setBody($typeDefinition->printTypeFactoryMethodBody());

            $fullClassName = $typeDefinition instanceof ClassTypeDefinition
                ? $typeDefinition->getFullClassName()
                : self::AUTOGENERATED;

            $this->typeMap[$typeName] = $fullClassName;

            $this->registerFieldInfos($typeDefinition);

            if ($typeDefinition instanceof ClassTypeDefinition && $typeDefinition->isAutoInstantiate()) {
                $this->autoInstantiate[$typeName] = $typeDefinition->getFullClassName();
            }

            if ($typeDefinition instanceof ClassTypeDefinition && $typeDefinition->isImplementingInterfaces()) {
                $this->invisibleTypes[] = $typeName;
            }
        }

    }

    private function registerFieldInfos(TypeDefinition $typeDefinition): void {
        $fieldDefinitions = $typeDefinition->getFieldDefinitions();

		$fieldInfos = [];

        foreach ($fieldDefinitions as $fieldDefinition) {
			$key = $typeDefinition->getName() . '::' . $fieldDefinition->getName();

			$fieldInfos[$key] = $fieldInfo = new FieldInfo();

            if (!$fieldDefinition instanceof PropertyFieldDefinition) {
                continue;
            }

			$fieldAttributes = $fieldDefinition->getAllFieldAttributes();
			$fieldInfo->setFieldAttributes($fieldAttributes);

            $resolveMethodDefinition = $fieldDefinition->getResolverMethodDefinition();

            if ($resolveMethodDefinition === null) {
                continue;
            }


			$fieldInfo->setResolveMethod($resolveMethodDefinition);

        }

		foreach ($fieldInfos as $key => $fieldInfo) {
			$this->fieldInfo[$key] = serialize($fieldInfo);
		}
    }



    private function addTypeMap(): void {
        $this->class
            ->addProperty('typeToClassname')
            ->setPrivate()
            ->setType('array')
            ->setValue($this->typeMap);

        $this->class
            ->addProperty('classnameToType')
            ->setPrivate()
            ->setType('array')
            ->setValue(array_flip($this->typeMap));
    }

    private function addAutoInstantiateProperty(): void {
        $this->class
            ->addProperty('autoInstantiate')
            ->setPrivate()
            ->setType('array')
            ->setValue($this->autoInstantiate);
    }

    private function addResolveMethodProperty(): void {
        $this->class
            ->addProperty('fieldInfo')
            ->setPrivate()
            ->setType('array')
            ->setValue($this->fieldInfo);
    }

    private function addInvisibleTypesProperty(): void {
        $this->class
            ->addProperty('invisibleTypes')
            ->setPrivate()
            ->setType('array')
            ->setValue($this->invisibleTypes);
    }

}
