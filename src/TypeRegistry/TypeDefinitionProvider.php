<?php

namespace Graphette\Graphette\TypeRegistry;

use GraphQL\Type\Definition\ListOfType;
use GraphQL\Type\Definition\NonNull;
use Nette\PhpGenerator\Dumper;
use Nette\PhpGenerator\Literal;
use Nette\Utils\Strings;
use Graphette\Graphette\Attribute\ObjectType;
use Graphette\Graphette\Attribute\Type;
use Graphette\Graphette\TypeRegistry\Definition\AutogeneratedTypeDefinition;
use Graphette\Graphette\TypeRegistry\Definition\ClassTypeDefinition;
use Graphette\Graphette\TypeRegistry\Definition\TypeDefinition;
use Graphette\Graphette\Utils\Attributes;
use Graphette\Graphette\Utils\Exception\AttributesException;

class TypeDefinitionProvider {

    /**
     * @var array<array{name: string, className: string}>
     */
    private static array $wrappingTypeDefinitions = [
        'list' => [
            'name' => 'List',
            'className' => ListOfType::class,
        ],
        'nonNull' => [
            'name' => 'NonNull',
            'className' => NonNull::class,
        ],
    ];

    /**
     * @var array<array{name: string, className: string, builtIn: bool}>
     */
    private static array $scalarTypeDefinitions;

    private TypeFinder $typeFinder;

    private TypeName $typeName;

    /** @var array<TypeDefinition> */
    private array $structuredTypeDefinitions;

    /** @var array<ClassTypeDefinition> */
    private array $queryTypeDefinitions = [];

    /** @var array<ClassTypeDefinition> */
    private array $mutationTypeDefinitions = [];

    /**
     * @param TypeFinder $typeFinder
     * @param TypeName $typeName
     */
    public function __construct(
        TypeFinder $typeFinder,
        TypeName   $typeName
    ) {
        $this->typeFinder = $typeFinder;
        $this->typeName = $typeName;
    }

    /**
     * @param array<array{name: string, className: string, builtIn: bool}> $scalarTypeDefinitions
     */
    public static function setScalarTypeDefinitions(array $scalarTypeDefinitions): void {
        self::$scalarTypeDefinitions = $scalarTypeDefinitions;
    }

    /**
     * @return array<array{name: string, className: string, builtIn: bool}>
     */
    public static function getScalarTypeDefinitions(): array {
        return self::$scalarTypeDefinitions;
    }

    /**
     * @param string $type
     * @return array{name: string, className: string, builtIn: bool}|null
     */
    public static function getScalarDefinitionByType(string $type): ?array {
        return self::$scalarTypeDefinitions[$type] ?? null;
    }

    /**
     * @param string $type
     * @return array{name: string, className: string, valueType: string, builtIn: bool}|null
     */
    public static function getScalarDefinitionByValueType(string $className): ?array {
        $scalarTypes = self::getScalarTypeDefinitions();

        foreach ($scalarTypes as $scalar) {
            if ($scalar['valueType'] === $className) {
                return $scalar;
            }
        }
        return null;
    }

    /**
     * @return array
     */
    public static function getWrappingTypeDefinitions(): array {
        return self::$wrappingTypeDefinitions;
    }

    /**
     * @return array<TypeDefinition>
     */
    public function getStructuredTypeDefinitions(): array {
        return $this->structuredTypeDefinitions ??= $this->parseStructuredTypeDefinitions();
    }

    /**
     * @return array<TypeDefinition>
     * @throws AttributesException
     * @throws \ReflectionException
     */
    private function parseStructuredTypeDefinitions(): array {
        $definitions = [];

        $reflectionClasses = $this->typeFinder->findTypes();

        foreach ($reflectionClasses as $reflectionClass) {
            /** @var Type|null $definitionAttribute */
            $definitionAttribute = Attributes::getSingleAttributeInstance($reflectionClass, Type::class);

            if ($definitionAttribute === null) {
                continue;
            }

            $name = $this->typeName->generate($reflectionClass);

            $definition = $definitions[] = new ClassTypeDefinition(
                $name,
                $reflectionClass,
                $definitionAttribute,
                fn(\ReflectionClass $reflectionClass) => $this->typeName->generate($reflectionClass)
            );

            // store types for autogenerated root type
            if ($definition->getShortClassName() === 'Queries') {
                $definition->setAutoInstantiate();
                $this->queryTypeDefinitions[] = $definition;
            }

            if ($definition->getShortClassName() === 'Mutations') {
                $definition->setAutoInstantiate();
                $this->mutationTypeDefinitions[] = $definition;
            }

        }

        if ($this->queryTypeDefinitions !== []) {
            $definitions[] = new AutogeneratedTypeDefinition('Query', $this->queryTypeDefinitions);
        }

        if ($this->mutationTypeDefinitions !== []) {
            $definitions[] = new AutogeneratedTypeDefinition('Mutation', $this->mutationTypeDefinitions);
        }


        return $definitions;
    }

}
